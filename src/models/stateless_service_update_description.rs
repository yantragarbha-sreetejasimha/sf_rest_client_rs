/*
 * Service Fabric Client APIs
 *
 * Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.
 *
 * OpenAPI spec version: 7.1.0.45
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// StatelessServiceUpdateDescription : Describes an update for a stateless service.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct StatelessServiceUpdateDescription {
    /// The service kind.
    #[serde(rename = "ServiceKind")]
    service_kind: ::models::ServiceKind,
    /// Flags indicating whether other properties are set. Each of the associated properties corresponds to a flag, specified below, which, if set, indicate that the property is specified. This property can be a combination of those flags obtained using bitwise 'OR' operator. For example, if the provided value is 6 then the flags for ReplicaRestartWaitDuration (2) and QuorumLossWaitDuration (4) are set.  - None - Does not indicate any other properties are set. The value is zero. - TargetReplicaSetSize/InstanceCount - Indicates whether the TargetReplicaSetSize property (for Stateful services) or the InstanceCount property (for Stateless services) is set. The value is 1. - ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration property is set. The value is  2. - QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property is set. The value is 4. - StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration property is set. The value is 8. - MinReplicaSetSize - Indicates the MinReplicaSetSize property is set. The value is 16. - PlacementConstraints - Indicates the PlacementConstraints property is set. The value is 32. - PlacementPolicyList - Indicates the ServicePlacementPolicies property is set. The value is 64. - Correlation - Indicates the CorrelationScheme property is set. The value is 128. - Metrics - Indicates the ServiceLoadMetrics property is set. The value is 256. - DefaultMoveCost - Indicates the DefaultMoveCost property is set. The value is 512. - ScalingPolicy - Indicates the ScalingPolicies property is set. The value is 1024. - ServicePlacementTimeLimit - Indicates the ServicePlacementTimeLimit property is set. The value is 2048. - MinInstanceCount - Indicates the MinInstanceCount property is set. The value is 4096. - MinInstancePercentage - Indicates the MinInstancePercentage property is set. The value is 8192. - InstanceCloseDelayDuration - Indicates the InstanceCloseDelayDuration property is set. The value is 16384.
    #[serde(rename = "Flags")]
    flags: Option<String>,
    /// The placement constraints as a string. Placement constraints are boolean expressions on node properties and allow for restricting a service to particular nodes based on the service requirements. For example, to place a service on nodes where NodeType is blue specify the following: \"NodeColor == blue)\".
    #[serde(rename = "PlacementConstraints")]
    placement_constraints: Option<String>,
    /// The correlation scheme.
    #[serde(rename = "CorrelationScheme")]
    correlation_scheme: Option<::models::CorrelationSchemeList>,
    /// The service load metrics.
    #[serde(rename = "LoadMetrics")]
    load_metrics: Option<::models::ServiceLoadMetricsList>,
    /// The service placement policies.
    #[serde(rename = "ServicePlacementPolicies")]
    service_placement_policies: Option<::models::ServicePlacementPoliciesList>,
    /// The move cost for the service.
    #[serde(rename = "DefaultMoveCost")]
    default_move_cost: Option<::models::MoveCost>,
    /// Scaling policies for this service.
    #[serde(rename = "ScalingPolicies")]
    scaling_policies: Option<::models::ScalingPolicyDescriptionList>,
    /// The instance count.
    #[serde(rename = "InstanceCount")]
    instance_count: Option<i32>,
    /// MinInstanceCount is the minimum number of instances that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
    #[serde(rename = "MinInstanceCount")]
    min_instance_count: Option<::models::MinInstanceCount>,
    /// MinInstancePercentage is the minimum percentage of InstanceCount that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
    #[serde(rename = "MinInstancePercentage")]
    min_instance_percentage: Option<::models::MinInstancePercentage>,
    /// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade and disabling node. The endpoint exposed on this instance is removed prior to starting the delay, which prevents new connections to this instance. In addition, clients that have subscribed to service endpoint change events(https://docs.microsoft.com/dotnet/api/system.fabric.fabricclient.servicemanagementclient.registerservicenotificationfilter_async), can do the following upon receiving the endpoint removal notification:     - Stop sending new requests to this instance.     - Close existing connections after in-flight requests have completed.     - Connect to a different instance of the service partition for future requests.
    #[serde(rename = "InstanceCloseDelayDurationSeconds")]
    instance_close_delay_duration_seconds: Option<String>,
}

impl StatelessServiceUpdateDescription {
    /// Describes an update for a stateless service.
    pub fn new(
        service_kind: ::models::ServiceKind,
    ) -> StatelessServiceUpdateDescription {
        StatelessServiceUpdateDescription {
            service_kind,
            flags: None,
            placement_constraints: None,
            correlation_scheme: None,
            load_metrics: None,
            service_placement_policies: None,
            default_move_cost: None,
            scaling_policies: None,
            instance_count: None,
            min_instance_count: None,
            min_instance_percentage: None,
            instance_close_delay_duration_seconds: None,
        }
    }

    pub fn set_service_kind(&mut self, service_kind: ::models::ServiceKind) {
        self.service_kind = service_kind;
    }

    pub fn with_service_kind(
        mut self,
        service_kind: ::models::ServiceKind,
    ) -> StatelessServiceUpdateDescription {
        self.service_kind = service_kind;
        self
    }

    pub fn service_kind(&self) -> &::models::ServiceKind {
        &self.service_kind
    }

    pub fn set_flags(&mut self, flags: String) {
        self.flags = Some(flags);
    }

    pub fn with_flags(
        mut self,
        flags: String,
    ) -> StatelessServiceUpdateDescription {
        self.flags = Some(flags);
        self
    }

    pub fn flags(&self) -> Option<&String> {
        self.flags.as_ref()
    }

    pub fn reset_flags(&mut self) {
        self.flags = None;
    }

    pub fn set_placement_constraints(&mut self, placement_constraints: String) {
        self.placement_constraints = Some(placement_constraints);
    }

    pub fn with_placement_constraints(
        mut self,
        placement_constraints: String,
    ) -> StatelessServiceUpdateDescription {
        self.placement_constraints = Some(placement_constraints);
        self
    }

    pub fn placement_constraints(&self) -> Option<&String> {
        self.placement_constraints.as_ref()
    }

    pub fn reset_placement_constraints(&mut self) {
        self.placement_constraints = None;
    }

    pub fn set_correlation_scheme(
        &mut self,
        correlation_scheme: ::models::CorrelationSchemeList,
    ) {
        self.correlation_scheme = Some(correlation_scheme);
    }

    pub fn with_correlation_scheme(
        mut self,
        correlation_scheme: ::models::CorrelationSchemeList,
    ) -> StatelessServiceUpdateDescription {
        self.correlation_scheme = Some(correlation_scheme);
        self
    }

    pub fn correlation_scheme(
        &self,
    ) -> Option<&::models::CorrelationSchemeList> {
        self.correlation_scheme.as_ref()
    }

    pub fn reset_correlation_scheme(&mut self) {
        self.correlation_scheme = None;
    }

    pub fn set_load_metrics(
        &mut self,
        load_metrics: ::models::ServiceLoadMetricsList,
    ) {
        self.load_metrics = Some(load_metrics);
    }

    pub fn with_load_metrics(
        mut self,
        load_metrics: ::models::ServiceLoadMetricsList,
    ) -> StatelessServiceUpdateDescription {
        self.load_metrics = Some(load_metrics);
        self
    }

    pub fn load_metrics(&self) -> Option<&::models::ServiceLoadMetricsList> {
        self.load_metrics.as_ref()
    }

    pub fn reset_load_metrics(&mut self) {
        self.load_metrics = None;
    }

    pub fn set_service_placement_policies(
        &mut self,
        service_placement_policies: ::models::ServicePlacementPoliciesList,
    ) {
        self.service_placement_policies = Some(service_placement_policies);
    }

    pub fn with_service_placement_policies(
        mut self,
        service_placement_policies: ::models::ServicePlacementPoliciesList,
    ) -> StatelessServiceUpdateDescription {
        self.service_placement_policies = Some(service_placement_policies);
        self
    }

    pub fn service_placement_policies(
        &self,
    ) -> Option<&::models::ServicePlacementPoliciesList> {
        self.service_placement_policies.as_ref()
    }

    pub fn reset_service_placement_policies(&mut self) {
        self.service_placement_policies = None;
    }

    pub fn set_default_move_cost(
        &mut self,
        default_move_cost: ::models::MoveCost,
    ) {
        self.default_move_cost = Some(default_move_cost);
    }

    pub fn with_default_move_cost(
        mut self,
        default_move_cost: ::models::MoveCost,
    ) -> StatelessServiceUpdateDescription {
        self.default_move_cost = Some(default_move_cost);
        self
    }

    pub fn default_move_cost(&self) -> Option<&::models::MoveCost> {
        self.default_move_cost.as_ref()
    }

    pub fn reset_default_move_cost(&mut self) {
        self.default_move_cost = None;
    }

    pub fn set_scaling_policies(
        &mut self,
        scaling_policies: ::models::ScalingPolicyDescriptionList,
    ) {
        self.scaling_policies = Some(scaling_policies);
    }

    pub fn with_scaling_policies(
        mut self,
        scaling_policies: ::models::ScalingPolicyDescriptionList,
    ) -> StatelessServiceUpdateDescription {
        self.scaling_policies = Some(scaling_policies);
        self
    }

    pub fn scaling_policies(
        &self,
    ) -> Option<&::models::ScalingPolicyDescriptionList> {
        self.scaling_policies.as_ref()
    }

    pub fn reset_scaling_policies(&mut self) {
        self.scaling_policies = None;
    }

    pub fn set_instance_count(&mut self, instance_count: i32) {
        self.instance_count = Some(instance_count);
    }

    pub fn with_instance_count(
        mut self,
        instance_count: i32,
    ) -> StatelessServiceUpdateDescription {
        self.instance_count = Some(instance_count);
        self
    }

    pub fn instance_count(&self) -> Option<&i32> {
        self.instance_count.as_ref()
    }

    pub fn reset_instance_count(&mut self) {
        self.instance_count = None;
    }

    pub fn set_min_instance_count(
        &mut self,
        min_instance_count: ::models::MinInstanceCount,
    ) {
        self.min_instance_count = Some(min_instance_count);
    }

    pub fn with_min_instance_count(
        mut self,
        min_instance_count: ::models::MinInstanceCount,
    ) -> StatelessServiceUpdateDescription {
        self.min_instance_count = Some(min_instance_count);
        self
    }

    pub fn min_instance_count(&self) -> Option<&::models::MinInstanceCount> {
        self.min_instance_count.as_ref()
    }

    pub fn reset_min_instance_count(&mut self) {
        self.min_instance_count = None;
    }

    pub fn set_min_instance_percentage(
        &mut self,
        min_instance_percentage: ::models::MinInstancePercentage,
    ) {
        self.min_instance_percentage = Some(min_instance_percentage);
    }

    pub fn with_min_instance_percentage(
        mut self,
        min_instance_percentage: ::models::MinInstancePercentage,
    ) -> StatelessServiceUpdateDescription {
        self.min_instance_percentage = Some(min_instance_percentage);
        self
    }

    pub fn min_instance_percentage(
        &self,
    ) -> Option<&::models::MinInstancePercentage> {
        self.min_instance_percentage.as_ref()
    }

    pub fn reset_min_instance_percentage(&mut self) {
        self.min_instance_percentage = None;
    }

    pub fn set_instance_close_delay_duration_seconds(
        &mut self,
        instance_close_delay_duration_seconds: String,
    ) {
        self.instance_close_delay_duration_seconds =
            Some(instance_close_delay_duration_seconds);
    }

    pub fn with_instance_close_delay_duration_seconds(
        mut self,
        instance_close_delay_duration_seconds: String,
    ) -> StatelessServiceUpdateDescription {
        self.instance_close_delay_duration_seconds =
            Some(instance_close_delay_duration_seconds);
        self
    }

    pub fn instance_close_delay_duration_seconds(&self) -> Option<&String> {
        self.instance_close_delay_duration_seconds.as_ref()
    }

    pub fn reset_instance_close_delay_duration_seconds(&mut self) {
        self.instance_close_delay_duration_seconds = None;
    }
}
