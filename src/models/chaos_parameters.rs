/*
 * Service Fabric Client APIs
 *
 * Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.
 *
 * OpenAPI spec version: 8.0
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// ChaosParameters : Defines all the parameters to configure a Chaos run.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct ChaosParameters {
    /// Total time (in seconds) for which Chaos will run before automatically stopping. The maximum allowed value is 4,294,967,295 (System.UInt32.MaxValue).
    #[serde(rename = "TimeToRunInSeconds")]
    time_to_run_in_seconds: Option<String>,
    /// The maximum amount of time to wait for all cluster entities to become stable and healthy. Chaos executes in iterations and at the start of each iteration it validates the health of cluster entities. During validation if a cluster entity is not stable and healthy within MaxClusterStabilizationTimeoutInSeconds, Chaos generates a validation failed event.
    #[serde(rename = "MaxClusterStabilizationTimeoutInSeconds")]
    max_cluster_stabilization_timeout_in_seconds: Option<i64>,
    /// MaxConcurrentFaults is the maximum number of concurrent faults induced per iteration. Chaos executes in iterations and two consecutive iterations are separated by a validation phase. The higher the concurrency, the more aggressive the injection of faults, leading to inducing more complex series of states to uncover bugs. The recommendation is to start with a value of 2 or 3 and to exercise caution while moving up.
    #[serde(rename = "MaxConcurrentFaults")]
    max_concurrent_faults: Option<i64>,
    /// Enables or disables the move primary and move secondary faults.
    #[serde(rename = "EnableMoveReplicaFaults")]
    enable_move_replica_faults: Option<bool>,
    /// Wait time (in seconds) between consecutive faults within a single iteration. The larger the value, the lower the overlapping between faults and the simpler the sequence of state transitions that the cluster goes through. The recommendation is to start with a value between 1 and 5 and exercise caution while moving up.
    #[serde(rename = "WaitTimeBetweenFaultsInSeconds")]
    wait_time_between_faults_in_seconds: Option<i64>,
    /// Time-separation (in seconds) between two consecutive iterations of Chaos. The larger the value, the lower the fault injection rate.
    #[serde(rename = "WaitTimeBetweenIterationsInSeconds")]
    wait_time_between_iterations_in_seconds: Option<i64>,
    /// Passed-in cluster health policy is used to validate health of the cluster in between Chaos iterations. If the cluster health is in error or if an unexpected exception happens during fault execution--to provide the cluster with some time to recuperate--Chaos will wait for 30 minutes before the next health-check.
    #[serde(rename = "ClusterHealthPolicy")]
    cluster_health_policy: Option<::models::ClusterHealthPolicy>,
    /// Describes a map, which is a collection of (string, string) type key-value pairs. The map can be used to record information about the Chaos run. There cannot be more than 100 such pairs and each string (key or value) can be at most 4095 characters long. This map is set by the starter of the Chaos run to optionally store the context about the specific run.
    #[serde(rename = "Context")]
    context: Option<::models::ChaosContext>,
    /// List of cluster entities to target for Chaos faults. This filter can be used to target Chaos faults only to certain node types or only to certain application instances. If ChaosTargetFilter is not used, Chaos faults all cluster entities. If ChaosTargetFilter is used, Chaos faults only the entities that meet the ChaosTargetFilter specification.
    #[serde(rename = "ChaosTargetFilter")]
    chaos_target_filter: Option<::models::ChaosTargetFilter>,
}

impl Default for ChaosParameters {
    fn default() -> Self {
        Self::new()
    }
}

impl ChaosParameters {
    /// Defines all the parameters to configure a Chaos run.
    pub fn new() -> ChaosParameters {
        ChaosParameters {
            time_to_run_in_seconds: None,
            max_cluster_stabilization_timeout_in_seconds: None,
            max_concurrent_faults: None,
            enable_move_replica_faults: None,
            wait_time_between_faults_in_seconds: None,
            wait_time_between_iterations_in_seconds: None,
            cluster_health_policy: None,
            context: None,
            chaos_target_filter: None,
        }
    }

    pub fn set_time_to_run_in_seconds(
        &mut self,
        time_to_run_in_seconds: String,
    ) {
        self.time_to_run_in_seconds = Some(time_to_run_in_seconds);
    }

    pub fn with_time_to_run_in_seconds(
        mut self,
        time_to_run_in_seconds: String,
    ) -> ChaosParameters {
        self.time_to_run_in_seconds = Some(time_to_run_in_seconds);
        self
    }

    pub fn time_to_run_in_seconds(&self) -> Option<&String> {
        self.time_to_run_in_seconds.as_ref()
    }

    pub fn reset_time_to_run_in_seconds(&mut self) {
        self.time_to_run_in_seconds = None;
    }

    pub fn set_max_cluster_stabilization_timeout_in_seconds(
        &mut self,
        max_cluster_stabilization_timeout_in_seconds: i64,
    ) {
        self.max_cluster_stabilization_timeout_in_seconds =
            Some(max_cluster_stabilization_timeout_in_seconds);
    }

    pub fn with_max_cluster_stabilization_timeout_in_seconds(
        mut self,
        max_cluster_stabilization_timeout_in_seconds: i64,
    ) -> ChaosParameters {
        self.max_cluster_stabilization_timeout_in_seconds =
            Some(max_cluster_stabilization_timeout_in_seconds);
        self
    }

    pub fn max_cluster_stabilization_timeout_in_seconds(&self) -> Option<&i64> {
        self.max_cluster_stabilization_timeout_in_seconds.as_ref()
    }

    pub fn reset_max_cluster_stabilization_timeout_in_seconds(&mut self) {
        self.max_cluster_stabilization_timeout_in_seconds = None;
    }

    pub fn set_max_concurrent_faults(&mut self, max_concurrent_faults: i64) {
        self.max_concurrent_faults = Some(max_concurrent_faults);
    }

    pub fn with_max_concurrent_faults(
        mut self,
        max_concurrent_faults: i64,
    ) -> ChaosParameters {
        self.max_concurrent_faults = Some(max_concurrent_faults);
        self
    }

    pub fn max_concurrent_faults(&self) -> Option<&i64> {
        self.max_concurrent_faults.as_ref()
    }

    pub fn reset_max_concurrent_faults(&mut self) {
        self.max_concurrent_faults = None;
    }

    pub fn set_enable_move_replica_faults(
        &mut self,
        enable_move_replica_faults: bool,
    ) {
        self.enable_move_replica_faults = Some(enable_move_replica_faults);
    }

    pub fn with_enable_move_replica_faults(
        mut self,
        enable_move_replica_faults: bool,
    ) -> ChaosParameters {
        self.enable_move_replica_faults = Some(enable_move_replica_faults);
        self
    }

    pub fn enable_move_replica_faults(&self) -> Option<&bool> {
        self.enable_move_replica_faults.as_ref()
    }

    pub fn reset_enable_move_replica_faults(&mut self) {
        self.enable_move_replica_faults = None;
    }

    pub fn set_wait_time_between_faults_in_seconds(
        &mut self,
        wait_time_between_faults_in_seconds: i64,
    ) {
        self.wait_time_between_faults_in_seconds =
            Some(wait_time_between_faults_in_seconds);
    }

    pub fn with_wait_time_between_faults_in_seconds(
        mut self,
        wait_time_between_faults_in_seconds: i64,
    ) -> ChaosParameters {
        self.wait_time_between_faults_in_seconds =
            Some(wait_time_between_faults_in_seconds);
        self
    }

    pub fn wait_time_between_faults_in_seconds(&self) -> Option<&i64> {
        self.wait_time_between_faults_in_seconds.as_ref()
    }

    pub fn reset_wait_time_between_faults_in_seconds(&mut self) {
        self.wait_time_between_faults_in_seconds = None;
    }

    pub fn set_wait_time_between_iterations_in_seconds(
        &mut self,
        wait_time_between_iterations_in_seconds: i64,
    ) {
        self.wait_time_between_iterations_in_seconds =
            Some(wait_time_between_iterations_in_seconds);
    }

    pub fn with_wait_time_between_iterations_in_seconds(
        mut self,
        wait_time_between_iterations_in_seconds: i64,
    ) -> ChaosParameters {
        self.wait_time_between_iterations_in_seconds =
            Some(wait_time_between_iterations_in_seconds);
        self
    }

    pub fn wait_time_between_iterations_in_seconds(&self) -> Option<&i64> {
        self.wait_time_between_iterations_in_seconds.as_ref()
    }

    pub fn reset_wait_time_between_iterations_in_seconds(&mut self) {
        self.wait_time_between_iterations_in_seconds = None;
    }

    pub fn set_cluster_health_policy(
        &mut self,
        cluster_health_policy: ::models::ClusterHealthPolicy,
    ) {
        self.cluster_health_policy = Some(cluster_health_policy);
    }

    pub fn with_cluster_health_policy(
        mut self,
        cluster_health_policy: ::models::ClusterHealthPolicy,
    ) -> ChaosParameters {
        self.cluster_health_policy = Some(cluster_health_policy);
        self
    }

    pub fn cluster_health_policy(
        &self,
    ) -> Option<&::models::ClusterHealthPolicy> {
        self.cluster_health_policy.as_ref()
    }

    pub fn reset_cluster_health_policy(&mut self) {
        self.cluster_health_policy = None;
    }

    pub fn set_context(&mut self, context: ::models::ChaosContext) {
        self.context = Some(context);
    }

    pub fn with_context(
        mut self,
        context: ::models::ChaosContext,
    ) -> ChaosParameters {
        self.context = Some(context);
        self
    }

    pub fn context(&self) -> Option<&::models::ChaosContext> {
        self.context.as_ref()
    }

    pub fn reset_context(&mut self) {
        self.context = None;
    }

    pub fn set_chaos_target_filter(
        &mut self,
        chaos_target_filter: ::models::ChaosTargetFilter,
    ) {
        self.chaos_target_filter = Some(chaos_target_filter);
    }

    pub fn with_chaos_target_filter(
        mut self,
        chaos_target_filter: ::models::ChaosTargetFilter,
    ) -> ChaosParameters {
        self.chaos_target_filter = Some(chaos_target_filter);
        self
    }

    pub fn chaos_target_filter(&self) -> Option<&::models::ChaosTargetFilter> {
        self.chaos_target_filter.as_ref()
    }

    pub fn reset_chaos_target_filter(&mut self) {
        self.chaos_target_filter = None;
    }
}
