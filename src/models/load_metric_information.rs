/*
 * Service Fabric Client APIs
 *
 * Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.
 *
 * OpenAPI spec version: 7.1.0.45
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// LoadMetricInformation : Represents data structure that contains load information for a certain metric in a cluster.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct LoadMetricInformation {
    /// Name of the metric for which this load information is provided.
    #[serde(rename = "Name")]
    name: Option<String>,
    /// Value that indicates whether the metrics is balanced or not before resource balancer run
    #[serde(rename = "IsBalancedBefore")]
    is_balanced_before: Option<bool>,
    /// Value that indicates whether the metrics is balanced or not after resource balancer run.
    #[serde(rename = "IsBalancedAfter")]
    is_balanced_after: Option<bool>,
    /// The standard average deviation of the metrics before resource balancer run.
    #[serde(rename = "DeviationBefore")]
    deviation_before: Option<String>,
    /// The standard average deviation of the metrics after resource balancer run.
    #[serde(rename = "DeviationAfter")]
    deviation_after: Option<String>,
    /// The balancing threshold for a certain metric.
    #[serde(rename = "BalancingThreshold")]
    balancing_threshold: Option<String>,
    /// The current action being taken with regard to this metric
    #[serde(rename = "Action")]
    action: Option<String>,
    /// The Activity Threshold specified for this metric in the system Cluster Manifest.
    #[serde(rename = "ActivityThreshold")]
    activity_threshold: Option<String>,
    /// The total cluster capacity for a given metric
    #[serde(rename = "ClusterCapacity")]
    cluster_capacity: Option<String>,
    /// The total cluster load. In future releases of Service Fabric this parameter will be deprecated in favor of CurrentClusterLoad.
    #[serde(rename = "ClusterLoad")]
    cluster_load: Option<String>,
    /// The total cluster load.
    #[serde(rename = "CurrentClusterLoad")]
    current_cluster_load: Option<String>,
    /// The remaining capacity for the metric in the cluster. In future releases of Service Fabric this parameter will be deprecated in favor of ClusterCapacityRemaining.
    #[serde(rename = "ClusterRemainingCapacity")]
    cluster_remaining_capacity: Option<String>,
    /// The remaining capacity for the metric in the cluster.
    #[serde(rename = "ClusterCapacityRemaining")]
    cluster_capacity_remaining: Option<String>,
    /// Indicates that the metric is currently over capacity in the cluster.
    #[serde(rename = "IsClusterCapacityViolation")]
    is_cluster_capacity_violation: Option<bool>,
    /// The reserved percentage of total node capacity for this metric.
    #[serde(rename = "NodeBufferPercentage")]
    node_buffer_percentage: Option<String>,
    /// Remaining capacity in the cluster excluding the reserved space. In future releases of Service Fabric this parameter will be deprecated in favor of BufferedClusterCapacityRemaining.
    #[serde(rename = "ClusterBufferedCapacity")]
    cluster_buffered_capacity: Option<String>,
    /// Remaining capacity in the cluster excluding the reserved space.
    #[serde(rename = "BufferedClusterCapacityRemaining")]
    buffered_cluster_capacity_remaining: Option<String>,
    /// The remaining percentage of cluster total capacity for this metric.
    #[serde(rename = "ClusterRemainingBufferedCapacity")]
    cluster_remaining_buffered_capacity: Option<String>,
    /// The minimum load on any node for this metric. In future releases of Service Fabric this parameter will be deprecated in favor of MinimumNodeLoad.
    #[serde(rename = "MinNodeLoadValue")]
    min_node_load_value: Option<String>,
    /// The minimum load on any node for this metric.
    #[serde(rename = "MinimumNodeLoad")]
    minimum_node_load: Option<String>,
    /// The node id of the node with the minimum load for this metric.
    #[serde(rename = "MinNodeLoadNodeId")]
    min_node_load_node_id: Option<::models::NodeId>,
    /// The maximum load on any node for this metric. In future releases of Service Fabric this parameter will be deprecated in favor of MaximumNodeLoad.
    #[serde(rename = "MaxNodeLoadValue")]
    max_node_load_value: Option<String>,
    /// The maximum load on any node for this metric.
    #[serde(rename = "MaximumNodeLoad")]
    maximum_node_load: Option<String>,
    /// The node id of the node with the maximum load for this metric.
    #[serde(rename = "MaxNodeLoadNodeId")]
    max_node_load_node_id: Option<::models::NodeId>,
    /// This value represents the load of the replicas that are planned to be removed in the future within the cluster. This kind of load is reported for replicas that are currently being moving to other nodes and for replicas that are currently being dropped but still use the load on the source node.
    #[serde(rename = "PlannedLoadRemoval")]
    planned_load_removal: Option<String>,
}

impl Default for LoadMetricInformation {
    fn default() -> Self {
        Self::new()
    }
}

impl LoadMetricInformation {
    /// Represents data structure that contains load information for a certain metric in a cluster.
    pub fn new() -> LoadMetricInformation {
        LoadMetricInformation {
            name: None,
            is_balanced_before: None,
            is_balanced_after: None,
            deviation_before: None,
            deviation_after: None,
            balancing_threshold: None,
            action: None,
            activity_threshold: None,
            cluster_capacity: None,
            cluster_load: None,
            current_cluster_load: None,
            cluster_remaining_capacity: None,
            cluster_capacity_remaining: None,
            is_cluster_capacity_violation: None,
            node_buffer_percentage: None,
            cluster_buffered_capacity: None,
            buffered_cluster_capacity_remaining: None,
            cluster_remaining_buffered_capacity: None,
            min_node_load_value: None,
            minimum_node_load: None,
            min_node_load_node_id: None,
            max_node_load_value: None,
            maximum_node_load: None,
            max_node_load_node_id: None,
            planned_load_removal: None,
        }
    }

    pub fn set_name(&mut self, name: String) {
        self.name = Some(name);
    }

    pub fn with_name(mut self, name: String) -> LoadMetricInformation {
        self.name = Some(name);
        self
    }

    pub fn name(&self) -> Option<&String> {
        self.name.as_ref()
    }

    pub fn reset_name(&mut self) {
        self.name = None;
    }

    pub fn set_is_balanced_before(&mut self, is_balanced_before: bool) {
        self.is_balanced_before = Some(is_balanced_before);
    }

    pub fn with_is_balanced_before(
        mut self,
        is_balanced_before: bool,
    ) -> LoadMetricInformation {
        self.is_balanced_before = Some(is_balanced_before);
        self
    }

    pub fn is_balanced_before(&self) -> Option<&bool> {
        self.is_balanced_before.as_ref()
    }

    pub fn reset_is_balanced_before(&mut self) {
        self.is_balanced_before = None;
    }

    pub fn set_is_balanced_after(&mut self, is_balanced_after: bool) {
        self.is_balanced_after = Some(is_balanced_after);
    }

    pub fn with_is_balanced_after(
        mut self,
        is_balanced_after: bool,
    ) -> LoadMetricInformation {
        self.is_balanced_after = Some(is_balanced_after);
        self
    }

    pub fn is_balanced_after(&self) -> Option<&bool> {
        self.is_balanced_after.as_ref()
    }

    pub fn reset_is_balanced_after(&mut self) {
        self.is_balanced_after = None;
    }

    pub fn set_deviation_before(&mut self, deviation_before: String) {
        self.deviation_before = Some(deviation_before);
    }

    pub fn with_deviation_before(
        mut self,
        deviation_before: String,
    ) -> LoadMetricInformation {
        self.deviation_before = Some(deviation_before);
        self
    }

    pub fn deviation_before(&self) -> Option<&String> {
        self.deviation_before.as_ref()
    }

    pub fn reset_deviation_before(&mut self) {
        self.deviation_before = None;
    }

    pub fn set_deviation_after(&mut self, deviation_after: String) {
        self.deviation_after = Some(deviation_after);
    }

    pub fn with_deviation_after(
        mut self,
        deviation_after: String,
    ) -> LoadMetricInformation {
        self.deviation_after = Some(deviation_after);
        self
    }

    pub fn deviation_after(&self) -> Option<&String> {
        self.deviation_after.as_ref()
    }

    pub fn reset_deviation_after(&mut self) {
        self.deviation_after = None;
    }

    pub fn set_balancing_threshold(&mut self, balancing_threshold: String) {
        self.balancing_threshold = Some(balancing_threshold);
    }

    pub fn with_balancing_threshold(
        mut self,
        balancing_threshold: String,
    ) -> LoadMetricInformation {
        self.balancing_threshold = Some(balancing_threshold);
        self
    }

    pub fn balancing_threshold(&self) -> Option<&String> {
        self.balancing_threshold.as_ref()
    }

    pub fn reset_balancing_threshold(&mut self) {
        self.balancing_threshold = None;
    }

    pub fn set_action(&mut self, action: String) {
        self.action = Some(action);
    }

    pub fn with_action(mut self, action: String) -> LoadMetricInformation {
        self.action = Some(action);
        self
    }

    pub fn action(&self) -> Option<&String> {
        self.action.as_ref()
    }

    pub fn reset_action(&mut self) {
        self.action = None;
    }

    pub fn set_activity_threshold(&mut self, activity_threshold: String) {
        self.activity_threshold = Some(activity_threshold);
    }

    pub fn with_activity_threshold(
        mut self,
        activity_threshold: String,
    ) -> LoadMetricInformation {
        self.activity_threshold = Some(activity_threshold);
        self
    }

    pub fn activity_threshold(&self) -> Option<&String> {
        self.activity_threshold.as_ref()
    }

    pub fn reset_activity_threshold(&mut self) {
        self.activity_threshold = None;
    }

    pub fn set_cluster_capacity(&mut self, cluster_capacity: String) {
        self.cluster_capacity = Some(cluster_capacity);
    }

    pub fn with_cluster_capacity(
        mut self,
        cluster_capacity: String,
    ) -> LoadMetricInformation {
        self.cluster_capacity = Some(cluster_capacity);
        self
    }

    pub fn cluster_capacity(&self) -> Option<&String> {
        self.cluster_capacity.as_ref()
    }

    pub fn reset_cluster_capacity(&mut self) {
        self.cluster_capacity = None;
    }

    pub fn set_cluster_load(&mut self, cluster_load: String) {
        self.cluster_load = Some(cluster_load);
    }

    pub fn with_cluster_load(
        mut self,
        cluster_load: String,
    ) -> LoadMetricInformation {
        self.cluster_load = Some(cluster_load);
        self
    }

    pub fn cluster_load(&self) -> Option<&String> {
        self.cluster_load.as_ref()
    }

    pub fn reset_cluster_load(&mut self) {
        self.cluster_load = None;
    }

    pub fn set_current_cluster_load(&mut self, current_cluster_load: String) {
        self.current_cluster_load = Some(current_cluster_load);
    }

    pub fn with_current_cluster_load(
        mut self,
        current_cluster_load: String,
    ) -> LoadMetricInformation {
        self.current_cluster_load = Some(current_cluster_load);
        self
    }

    pub fn current_cluster_load(&self) -> Option<&String> {
        self.current_cluster_load.as_ref()
    }

    pub fn reset_current_cluster_load(&mut self) {
        self.current_cluster_load = None;
    }

    pub fn set_cluster_remaining_capacity(
        &mut self,
        cluster_remaining_capacity: String,
    ) {
        self.cluster_remaining_capacity = Some(cluster_remaining_capacity);
    }

    pub fn with_cluster_remaining_capacity(
        mut self,
        cluster_remaining_capacity: String,
    ) -> LoadMetricInformation {
        self.cluster_remaining_capacity = Some(cluster_remaining_capacity);
        self
    }

    pub fn cluster_remaining_capacity(&self) -> Option<&String> {
        self.cluster_remaining_capacity.as_ref()
    }

    pub fn reset_cluster_remaining_capacity(&mut self) {
        self.cluster_remaining_capacity = None;
    }

    pub fn set_cluster_capacity_remaining(
        &mut self,
        cluster_capacity_remaining: String,
    ) {
        self.cluster_capacity_remaining = Some(cluster_capacity_remaining);
    }

    pub fn with_cluster_capacity_remaining(
        mut self,
        cluster_capacity_remaining: String,
    ) -> LoadMetricInformation {
        self.cluster_capacity_remaining = Some(cluster_capacity_remaining);
        self
    }

    pub fn cluster_capacity_remaining(&self) -> Option<&String> {
        self.cluster_capacity_remaining.as_ref()
    }

    pub fn reset_cluster_capacity_remaining(&mut self) {
        self.cluster_capacity_remaining = None;
    }

    pub fn set_is_cluster_capacity_violation(
        &mut self,
        is_cluster_capacity_violation: bool,
    ) {
        self.is_cluster_capacity_violation =
            Some(is_cluster_capacity_violation);
    }

    pub fn with_is_cluster_capacity_violation(
        mut self,
        is_cluster_capacity_violation: bool,
    ) -> LoadMetricInformation {
        self.is_cluster_capacity_violation =
            Some(is_cluster_capacity_violation);
        self
    }

    pub fn is_cluster_capacity_violation(&self) -> Option<&bool> {
        self.is_cluster_capacity_violation.as_ref()
    }

    pub fn reset_is_cluster_capacity_violation(&mut self) {
        self.is_cluster_capacity_violation = None;
    }

    pub fn set_node_buffer_percentage(
        &mut self,
        node_buffer_percentage: String,
    ) {
        self.node_buffer_percentage = Some(node_buffer_percentage);
    }

    pub fn with_node_buffer_percentage(
        mut self,
        node_buffer_percentage: String,
    ) -> LoadMetricInformation {
        self.node_buffer_percentage = Some(node_buffer_percentage);
        self
    }

    pub fn node_buffer_percentage(&self) -> Option<&String> {
        self.node_buffer_percentage.as_ref()
    }

    pub fn reset_node_buffer_percentage(&mut self) {
        self.node_buffer_percentage = None;
    }

    pub fn set_cluster_buffered_capacity(
        &mut self,
        cluster_buffered_capacity: String,
    ) {
        self.cluster_buffered_capacity = Some(cluster_buffered_capacity);
    }

    pub fn with_cluster_buffered_capacity(
        mut self,
        cluster_buffered_capacity: String,
    ) -> LoadMetricInformation {
        self.cluster_buffered_capacity = Some(cluster_buffered_capacity);
        self
    }

    pub fn cluster_buffered_capacity(&self) -> Option<&String> {
        self.cluster_buffered_capacity.as_ref()
    }

    pub fn reset_cluster_buffered_capacity(&mut self) {
        self.cluster_buffered_capacity = None;
    }

    pub fn set_buffered_cluster_capacity_remaining(
        &mut self,
        buffered_cluster_capacity_remaining: String,
    ) {
        self.buffered_cluster_capacity_remaining =
            Some(buffered_cluster_capacity_remaining);
    }

    pub fn with_buffered_cluster_capacity_remaining(
        mut self,
        buffered_cluster_capacity_remaining: String,
    ) -> LoadMetricInformation {
        self.buffered_cluster_capacity_remaining =
            Some(buffered_cluster_capacity_remaining);
        self
    }

    pub fn buffered_cluster_capacity_remaining(&self) -> Option<&String> {
        self.buffered_cluster_capacity_remaining.as_ref()
    }

    pub fn reset_buffered_cluster_capacity_remaining(&mut self) {
        self.buffered_cluster_capacity_remaining = None;
    }

    pub fn set_cluster_remaining_buffered_capacity(
        &mut self,
        cluster_remaining_buffered_capacity: String,
    ) {
        self.cluster_remaining_buffered_capacity =
            Some(cluster_remaining_buffered_capacity);
    }

    pub fn with_cluster_remaining_buffered_capacity(
        mut self,
        cluster_remaining_buffered_capacity: String,
    ) -> LoadMetricInformation {
        self.cluster_remaining_buffered_capacity =
            Some(cluster_remaining_buffered_capacity);
        self
    }

    pub fn cluster_remaining_buffered_capacity(&self) -> Option<&String> {
        self.cluster_remaining_buffered_capacity.as_ref()
    }

    pub fn reset_cluster_remaining_buffered_capacity(&mut self) {
        self.cluster_remaining_buffered_capacity = None;
    }

    pub fn set_min_node_load_value(&mut self, min_node_load_value: String) {
        self.min_node_load_value = Some(min_node_load_value);
    }

    pub fn with_min_node_load_value(
        mut self,
        min_node_load_value: String,
    ) -> LoadMetricInformation {
        self.min_node_load_value = Some(min_node_load_value);
        self
    }

    pub fn min_node_load_value(&self) -> Option<&String> {
        self.min_node_load_value.as_ref()
    }

    pub fn reset_min_node_load_value(&mut self) {
        self.min_node_load_value = None;
    }

    pub fn set_minimum_node_load(&mut self, minimum_node_load: String) {
        self.minimum_node_load = Some(minimum_node_load);
    }

    pub fn with_minimum_node_load(
        mut self,
        minimum_node_load: String,
    ) -> LoadMetricInformation {
        self.minimum_node_load = Some(minimum_node_load);
        self
    }

    pub fn minimum_node_load(&self) -> Option<&String> {
        self.minimum_node_load.as_ref()
    }

    pub fn reset_minimum_node_load(&mut self) {
        self.minimum_node_load = None;
    }

    pub fn set_min_node_load_node_id(
        &mut self,
        min_node_load_node_id: ::models::NodeId,
    ) {
        self.min_node_load_node_id = Some(min_node_load_node_id);
    }

    pub fn with_min_node_load_node_id(
        mut self,
        min_node_load_node_id: ::models::NodeId,
    ) -> LoadMetricInformation {
        self.min_node_load_node_id = Some(min_node_load_node_id);
        self
    }

    pub fn min_node_load_node_id(&self) -> Option<&::models::NodeId> {
        self.min_node_load_node_id.as_ref()
    }

    pub fn reset_min_node_load_node_id(&mut self) {
        self.min_node_load_node_id = None;
    }

    pub fn set_max_node_load_value(&mut self, max_node_load_value: String) {
        self.max_node_load_value = Some(max_node_load_value);
    }

    pub fn with_max_node_load_value(
        mut self,
        max_node_load_value: String,
    ) -> LoadMetricInformation {
        self.max_node_load_value = Some(max_node_load_value);
        self
    }

    pub fn max_node_load_value(&self) -> Option<&String> {
        self.max_node_load_value.as_ref()
    }

    pub fn reset_max_node_load_value(&mut self) {
        self.max_node_load_value = None;
    }

    pub fn set_maximum_node_load(&mut self, maximum_node_load: String) {
        self.maximum_node_load = Some(maximum_node_load);
    }

    pub fn with_maximum_node_load(
        mut self,
        maximum_node_load: String,
    ) -> LoadMetricInformation {
        self.maximum_node_load = Some(maximum_node_load);
        self
    }

    pub fn maximum_node_load(&self) -> Option<&String> {
        self.maximum_node_load.as_ref()
    }

    pub fn reset_maximum_node_load(&mut self) {
        self.maximum_node_load = None;
    }

    pub fn set_max_node_load_node_id(
        &mut self,
        max_node_load_node_id: ::models::NodeId,
    ) {
        self.max_node_load_node_id = Some(max_node_load_node_id);
    }

    pub fn with_max_node_load_node_id(
        mut self,
        max_node_load_node_id: ::models::NodeId,
    ) -> LoadMetricInformation {
        self.max_node_load_node_id = Some(max_node_load_node_id);
        self
    }

    pub fn max_node_load_node_id(&self) -> Option<&::models::NodeId> {
        self.max_node_load_node_id.as_ref()
    }

    pub fn reset_max_node_load_node_id(&mut self) {
        self.max_node_load_node_id = None;
    }

    pub fn set_planned_load_removal(&mut self, planned_load_removal: String) {
        self.planned_load_removal = Some(planned_load_removal);
    }

    pub fn with_planned_load_removal(
        mut self,
        planned_load_removal: String,
    ) -> LoadMetricInformation {
        self.planned_load_removal = Some(planned_load_removal);
        self
    }

    pub fn planned_load_removal(&self) -> Option<&String> {
        self.planned_load_removal.as_ref()
    }

    pub fn reset_planned_load_removal(&mut self) {
        self.planned_load_removal = None;
    }
}
