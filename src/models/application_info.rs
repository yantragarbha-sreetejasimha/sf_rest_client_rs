/*
 * Service Fabric Client APIs
 *
 * Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.
 *
 * OpenAPI spec version: 7.1.0.45
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// ApplicationInfo : Information about a Service Fabric application.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct ApplicationInfo {
    /// The identity of the application. This is an encoded representation of the application name. This is used in the REST APIs to identify the application resource. Starting in version 6.0, hierarchical names are delimited with the \"\\~\" character. For example, if the application name is \"fabric:/myapp/app1\", the application identity would be \"myapp\\~app1\" in 6.0+ and \"myapp/app1\" in previous versions.
    #[serde(rename = "Id")]
    id: Option<::models::ApplicationId>,
    /// The name of the application, including the 'fabric:' URI scheme.
    #[serde(rename = "Name")]
    name: Option<::models::ApplicationName>,
    /// The application type name as defined in the application manifest.
    #[serde(rename = "TypeName")]
    type_name: Option<::models::ApplicationTypeName>,
    /// The version of the application type as defined in the application manifest.
    #[serde(rename = "TypeVersion")]
    type_version: Option<::models::ApplicationTypeVersion>,
    /// The status of the application.
    #[serde(rename = "Status")]
    status: Option<::models::ApplicationStatus>,
    /// List of application parameters with overridden values from their default values specified in the application manifest.
    #[serde(rename = "Parameters")]
    parameters: Option<::models::ApplicationParameterList>,
    /// The health state of a Service Fabric entity such as Cluster, Node, Application, Service, Partition, Replica etc.
    #[serde(rename = "HealthState")]
    health_state: Option<::models::HealthState>,
    /// The mechanism used to define a Service Fabric application.
    #[serde(rename = "ApplicationDefinitionKind")]
    application_definition_kind: Option<::models::ApplicationDefinitionKind>,
}

impl Default for ApplicationInfo {
    fn default() -> Self {
        Self::new()
    }
}

impl ApplicationInfo {
    /// Information about a Service Fabric application.
    pub fn new() -> ApplicationInfo {
        ApplicationInfo {
            id: None,
            name: None,
            type_name: None,
            type_version: None,
            status: None,
            parameters: None,
            health_state: None,
            application_definition_kind: None,
        }
    }

    pub fn set_id(&mut self, id: ::models::ApplicationId) {
        self.id = Some(id);
    }

    pub fn with_id(mut self, id: ::models::ApplicationId) -> ApplicationInfo {
        self.id = Some(id);
        self
    }

    pub fn id(&self) -> Option<&::models::ApplicationId> {
        self.id.as_ref()
    }

    pub fn reset_id(&mut self) {
        self.id = None;
    }

    pub fn set_name(&mut self, name: ::models::ApplicationName) {
        self.name = Some(name);
    }

    pub fn with_name(
        mut self,
        name: ::models::ApplicationName,
    ) -> ApplicationInfo {
        self.name = Some(name);
        self
    }

    pub fn name(&self) -> Option<&::models::ApplicationName> {
        self.name.as_ref()
    }

    pub fn reset_name(&mut self) {
        self.name = None;
    }

    pub fn set_type_name(&mut self, type_name: ::models::ApplicationTypeName) {
        self.type_name = Some(type_name);
    }

    pub fn with_type_name(
        mut self,
        type_name: ::models::ApplicationTypeName,
    ) -> ApplicationInfo {
        self.type_name = Some(type_name);
        self
    }

    pub fn type_name(&self) -> Option<&::models::ApplicationTypeName> {
        self.type_name.as_ref()
    }

    pub fn reset_type_name(&mut self) {
        self.type_name = None;
    }

    pub fn set_type_version(
        &mut self,
        type_version: ::models::ApplicationTypeVersion,
    ) {
        self.type_version = Some(type_version);
    }

    pub fn with_type_version(
        mut self,
        type_version: ::models::ApplicationTypeVersion,
    ) -> ApplicationInfo {
        self.type_version = Some(type_version);
        self
    }

    pub fn type_version(&self) -> Option<&::models::ApplicationTypeVersion> {
        self.type_version.as_ref()
    }

    pub fn reset_type_version(&mut self) {
        self.type_version = None;
    }

    pub fn set_status(&mut self, status: ::models::ApplicationStatus) {
        self.status = Some(status);
    }

    pub fn with_status(
        mut self,
        status: ::models::ApplicationStatus,
    ) -> ApplicationInfo {
        self.status = Some(status);
        self
    }

    pub fn status(&self) -> Option<&::models::ApplicationStatus> {
        self.status.as_ref()
    }

    pub fn reset_status(&mut self) {
        self.status = None;
    }

    pub fn set_parameters(
        &mut self,
        parameters: ::models::ApplicationParameterList,
    ) {
        self.parameters = Some(parameters);
    }

    pub fn with_parameters(
        mut self,
        parameters: ::models::ApplicationParameterList,
    ) -> ApplicationInfo {
        self.parameters = Some(parameters);
        self
    }

    pub fn parameters(&self) -> Option<&::models::ApplicationParameterList> {
        self.parameters.as_ref()
    }

    pub fn reset_parameters(&mut self) {
        self.parameters = None;
    }

    pub fn set_health_state(&mut self, health_state: ::models::HealthState) {
        self.health_state = Some(health_state);
    }

    pub fn with_health_state(
        mut self,
        health_state: ::models::HealthState,
    ) -> ApplicationInfo {
        self.health_state = Some(health_state);
        self
    }

    pub fn health_state(&self) -> Option<&::models::HealthState> {
        self.health_state.as_ref()
    }

    pub fn reset_health_state(&mut self) {
        self.health_state = None;
    }

    pub fn set_application_definition_kind(
        &mut self,
        application_definition_kind: ::models::ApplicationDefinitionKind,
    ) {
        self.application_definition_kind = Some(application_definition_kind);
    }

    pub fn with_application_definition_kind(
        mut self,
        application_definition_kind: ::models::ApplicationDefinitionKind,
    ) -> ApplicationInfo {
        self.application_definition_kind = Some(application_definition_kind);
        self
    }

    pub fn application_definition_kind(
        &self,
    ) -> Option<&::models::ApplicationDefinitionKind> {
        self.application_definition_kind.as_ref()
    }

    pub fn reset_application_definition_kind(&mut self) {
        self.application_definition_kind = None;
    }
}
