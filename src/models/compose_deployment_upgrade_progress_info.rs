/*
 * Service Fabric Client APIs
 *
 * Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.
 *
 * OpenAPI spec version: 8.1
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// ComposeDeploymentUpgradeProgressInfo : Describes the parameters for a compose deployment upgrade.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct ComposeDeploymentUpgradeProgressInfo {
    /// The name of the target deployment.
    #[serde(rename = "DeploymentName")]
    deployment_name: Option<::models::TargetDeploymentName>,
    /// The name of the target application, including the 'fabric:' URI scheme.
    #[serde(rename = "ApplicationName")]
    application_name: Option<::models::TargetApplicationName>,
    /// The state of the compose deployment upgrade.
    #[serde(rename = "UpgradeState")]
    upgrade_state: Option<::models::ComposeDeploymentUpgradeState>,
    /// Additional detailed information about the status of the pending upgrade.
    #[serde(rename = "UpgradeStatusDetails")]
    upgrade_status_details: Option<String>,
    /// The kind of upgrade out of the following possible values.
    #[serde(rename = "UpgradeKind")]
    upgrade_kind: Option<::models::UpgradeKind>,
    /// The mode used to monitor health during a rolling upgrade. The values are UnmonitoredAuto, UnmonitoredManual, and Monitored.
    #[serde(rename = "RollingUpgradeMode")]
    rolling_upgrade_mode: Option<::models::UpgradeMode>,
    /// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
    #[serde(rename = "ForceRestart")]
    force_restart: Option<::models::ForceRestart>,
    /// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
    #[serde(rename = "UpgradeReplicaSetCheckTimeoutInSeconds")]
    upgrade_replica_set_check_timeout_in_seconds:
        Option<::models::UpgradeReplicaSetCheckTimeout>,
    /// Describes the parameters for monitoring an upgrade in Monitored mode.
    #[serde(rename = "MonitoringPolicy")]
    monitoring_policy: Option<::models::MonitoringPolicyDescription>,
    /// Defines a health policy used to evaluate the health of an application or one of its children entities.
    #[serde(rename = "ApplicationHealthPolicy")]
    application_health_policy: Option<::models::ApplicationHealthPolicy>,
    /// The target application type version (found in the application manifest) for the application upgrade.
    #[serde(rename = "TargetApplicationTypeVersion")]
    target_application_type_version:
        Option<::models::TargetApplicationTypeVersion>,
    /// The estimated amount of time that the overall upgrade elapsed. It is first interpreted as a string representing an ISO 8601 duration. If that fails, then it is interpreted as a number representing the total number of milliseconds.
    #[serde(rename = "UpgradeDuration")]
    upgrade_duration: Option<::models::UpgradeDuration>,
    /// The estimated amount of time spent processing current Upgrade Domain. It is first interpreted as a string representing an ISO 8601 duration. If that fails, then it is interpreted as a number representing the total number of milliseconds.
    #[serde(rename = "CurrentUpgradeDomainDuration")]
    current_upgrade_domain_duration:
        Option<::models::CurrentUpgradeDomainDuration>,
    /// List of health evaluations that resulted in the current aggregated health state.
    #[serde(rename = "ApplicationUnhealthyEvaluations")]
    application_unhealthy_evaluations:
        Option<::models::ApplicationUnhealthyEvaluations>,
    /// Information about the current in-progress upgrade domain.
    #[serde(rename = "CurrentUpgradeDomainProgress")]
    current_upgrade_domain_progress:
        Option<::models::CurrentUpgradeDomainProgressInfo>,
    /// The estimated UTC datetime when the upgrade started.
    #[serde(rename = "StartTimestampUtc")]
    start_timestamp_utc: Option<String>,
    /// The estimated UTC datetime when the upgrade failed and FailureAction was executed.
    #[serde(rename = "FailureTimestampUtc")]
    failure_timestamp_utc: Option<String>,
    /// The cause of an upgrade failure that resulted in FailureAction being executed.
    #[serde(rename = "FailureReason")]
    failure_reason: Option<::models::FailureReason>,
    /// Information about the upgrade domain progress at the time of upgrade failure.
    #[serde(rename = "UpgradeDomainProgressAtFailure")]
    upgrade_domain_progress_at_failure:
        Option<::models::FailureUpgradeDomainProgressInfo>,
    /// Additional details of application upgrade including failure message.
    #[serde(rename = "ApplicationUpgradeStatusDetails")]
    application_upgrade_status_details: Option<String>,
}

impl Default for ComposeDeploymentUpgradeProgressInfo {
    fn default() -> Self {
        Self::new()
    }
}

impl ComposeDeploymentUpgradeProgressInfo {
    /// Describes the parameters for a compose deployment upgrade.
    pub fn new() -> ComposeDeploymentUpgradeProgressInfo {
        ComposeDeploymentUpgradeProgressInfo {
            deployment_name: None,
            application_name: None,
            upgrade_state: None,
            upgrade_status_details: None,
            upgrade_kind: None,
            rolling_upgrade_mode: None,
            force_restart: None,
            upgrade_replica_set_check_timeout_in_seconds: None,
            monitoring_policy: None,
            application_health_policy: None,
            target_application_type_version: None,
            upgrade_duration: None,
            current_upgrade_domain_duration: None,
            application_unhealthy_evaluations: None,
            current_upgrade_domain_progress: None,
            start_timestamp_utc: None,
            failure_timestamp_utc: None,
            failure_reason: None,
            upgrade_domain_progress_at_failure: None,
            application_upgrade_status_details: None,
        }
    }

    pub fn set_deployment_name(
        &mut self,
        deployment_name: ::models::TargetDeploymentName,
    ) {
        self.deployment_name = Some(deployment_name);
    }

    pub fn with_deployment_name(
        mut self,
        deployment_name: ::models::TargetDeploymentName,
    ) -> ComposeDeploymentUpgradeProgressInfo {
        self.deployment_name = Some(deployment_name);
        self
    }

    pub fn deployment_name(&self) -> Option<&::models::TargetDeploymentName> {
        self.deployment_name.as_ref()
    }

    pub fn reset_deployment_name(&mut self) {
        self.deployment_name = None;
    }

    pub fn set_application_name(
        &mut self,
        application_name: ::models::TargetApplicationName,
    ) {
        self.application_name = Some(application_name);
    }

    pub fn with_application_name(
        mut self,
        application_name: ::models::TargetApplicationName,
    ) -> ComposeDeploymentUpgradeProgressInfo {
        self.application_name = Some(application_name);
        self
    }

    pub fn application_name(&self) -> Option<&::models::TargetApplicationName> {
        self.application_name.as_ref()
    }

    pub fn reset_application_name(&mut self) {
        self.application_name = None;
    }

    pub fn set_upgrade_state(
        &mut self,
        upgrade_state: ::models::ComposeDeploymentUpgradeState,
    ) {
        self.upgrade_state = Some(upgrade_state);
    }

    pub fn with_upgrade_state(
        mut self,
        upgrade_state: ::models::ComposeDeploymentUpgradeState,
    ) -> ComposeDeploymentUpgradeProgressInfo {
        self.upgrade_state = Some(upgrade_state);
        self
    }

    pub fn upgrade_state(
        &self,
    ) -> Option<&::models::ComposeDeploymentUpgradeState> {
        self.upgrade_state.as_ref()
    }

    pub fn reset_upgrade_state(&mut self) {
        self.upgrade_state = None;
    }

    pub fn set_upgrade_status_details(
        &mut self,
        upgrade_status_details: String,
    ) {
        self.upgrade_status_details = Some(upgrade_status_details);
    }

    pub fn with_upgrade_status_details(
        mut self,
        upgrade_status_details: String,
    ) -> ComposeDeploymentUpgradeProgressInfo {
        self.upgrade_status_details = Some(upgrade_status_details);
        self
    }

    pub fn upgrade_status_details(&self) -> Option<&String> {
        self.upgrade_status_details.as_ref()
    }

    pub fn reset_upgrade_status_details(&mut self) {
        self.upgrade_status_details = None;
    }

    pub fn set_upgrade_kind(&mut self, upgrade_kind: ::models::UpgradeKind) {
        self.upgrade_kind = Some(upgrade_kind);
    }

    pub fn with_upgrade_kind(
        mut self,
        upgrade_kind: ::models::UpgradeKind,
    ) -> ComposeDeploymentUpgradeProgressInfo {
        self.upgrade_kind = Some(upgrade_kind);
        self
    }

    pub fn upgrade_kind(&self) -> Option<&::models::UpgradeKind> {
        self.upgrade_kind.as_ref()
    }

    pub fn reset_upgrade_kind(&mut self) {
        self.upgrade_kind = None;
    }

    pub fn set_rolling_upgrade_mode(
        &mut self,
        rolling_upgrade_mode: ::models::UpgradeMode,
    ) {
        self.rolling_upgrade_mode = Some(rolling_upgrade_mode);
    }

    pub fn with_rolling_upgrade_mode(
        mut self,
        rolling_upgrade_mode: ::models::UpgradeMode,
    ) -> ComposeDeploymentUpgradeProgressInfo {
        self.rolling_upgrade_mode = Some(rolling_upgrade_mode);
        self
    }

    pub fn rolling_upgrade_mode(&self) -> Option<&::models::UpgradeMode> {
        self.rolling_upgrade_mode.as_ref()
    }

    pub fn reset_rolling_upgrade_mode(&mut self) {
        self.rolling_upgrade_mode = None;
    }

    pub fn set_force_restart(&mut self, force_restart: ::models::ForceRestart) {
        self.force_restart = Some(force_restart);
    }

    pub fn with_force_restart(
        mut self,
        force_restart: ::models::ForceRestart,
    ) -> ComposeDeploymentUpgradeProgressInfo {
        self.force_restart = Some(force_restart);
        self
    }

    pub fn force_restart(&self) -> Option<&::models::ForceRestart> {
        self.force_restart.as_ref()
    }

    pub fn reset_force_restart(&mut self) {
        self.force_restart = None;
    }

    pub fn set_upgrade_replica_set_check_timeout_in_seconds(
        &mut self,
        upgrade_replica_set_check_timeout_in_seconds: ::models::UpgradeReplicaSetCheckTimeout,
    ) {
        self.upgrade_replica_set_check_timeout_in_seconds =
            Some(upgrade_replica_set_check_timeout_in_seconds);
    }

    pub fn with_upgrade_replica_set_check_timeout_in_seconds(
        mut self,
        upgrade_replica_set_check_timeout_in_seconds: ::models::UpgradeReplicaSetCheckTimeout,
    ) -> ComposeDeploymentUpgradeProgressInfo {
        self.upgrade_replica_set_check_timeout_in_seconds =
            Some(upgrade_replica_set_check_timeout_in_seconds);
        self
    }

    pub fn upgrade_replica_set_check_timeout_in_seconds(
        &self,
    ) -> Option<&::models::UpgradeReplicaSetCheckTimeout> {
        self.upgrade_replica_set_check_timeout_in_seconds.as_ref()
    }

    pub fn reset_upgrade_replica_set_check_timeout_in_seconds(&mut self) {
        self.upgrade_replica_set_check_timeout_in_seconds = None;
    }

    pub fn set_monitoring_policy(
        &mut self,
        monitoring_policy: ::models::MonitoringPolicyDescription,
    ) {
        self.monitoring_policy = Some(monitoring_policy);
    }

    pub fn with_monitoring_policy(
        mut self,
        monitoring_policy: ::models::MonitoringPolicyDescription,
    ) -> ComposeDeploymentUpgradeProgressInfo {
        self.monitoring_policy = Some(monitoring_policy);
        self
    }

    pub fn monitoring_policy(
        &self,
    ) -> Option<&::models::MonitoringPolicyDescription> {
        self.monitoring_policy.as_ref()
    }

    pub fn reset_monitoring_policy(&mut self) {
        self.monitoring_policy = None;
    }

    pub fn set_application_health_policy(
        &mut self,
        application_health_policy: ::models::ApplicationHealthPolicy,
    ) {
        self.application_health_policy = Some(application_health_policy);
    }

    pub fn with_application_health_policy(
        mut self,
        application_health_policy: ::models::ApplicationHealthPolicy,
    ) -> ComposeDeploymentUpgradeProgressInfo {
        self.application_health_policy = Some(application_health_policy);
        self
    }

    pub fn application_health_policy(
        &self,
    ) -> Option<&::models::ApplicationHealthPolicy> {
        self.application_health_policy.as_ref()
    }

    pub fn reset_application_health_policy(&mut self) {
        self.application_health_policy = None;
    }

    pub fn set_target_application_type_version(
        &mut self,
        target_application_type_version: ::models::TargetApplicationTypeVersion,
    ) {
        self.target_application_type_version =
            Some(target_application_type_version);
    }

    pub fn with_target_application_type_version(
        mut self,
        target_application_type_version: ::models::TargetApplicationTypeVersion,
    ) -> ComposeDeploymentUpgradeProgressInfo {
        self.target_application_type_version =
            Some(target_application_type_version);
        self
    }

    pub fn target_application_type_version(
        &self,
    ) -> Option<&::models::TargetApplicationTypeVersion> {
        self.target_application_type_version.as_ref()
    }

    pub fn reset_target_application_type_version(&mut self) {
        self.target_application_type_version = None;
    }

    pub fn set_upgrade_duration(
        &mut self,
        upgrade_duration: ::models::UpgradeDuration,
    ) {
        self.upgrade_duration = Some(upgrade_duration);
    }

    pub fn with_upgrade_duration(
        mut self,
        upgrade_duration: ::models::UpgradeDuration,
    ) -> ComposeDeploymentUpgradeProgressInfo {
        self.upgrade_duration = Some(upgrade_duration);
        self
    }

    pub fn upgrade_duration(&self) -> Option<&::models::UpgradeDuration> {
        self.upgrade_duration.as_ref()
    }

    pub fn reset_upgrade_duration(&mut self) {
        self.upgrade_duration = None;
    }

    pub fn set_current_upgrade_domain_duration(
        &mut self,
        current_upgrade_domain_duration: ::models::CurrentUpgradeDomainDuration,
    ) {
        self.current_upgrade_domain_duration =
            Some(current_upgrade_domain_duration);
    }

    pub fn with_current_upgrade_domain_duration(
        mut self,
        current_upgrade_domain_duration: ::models::CurrentUpgradeDomainDuration,
    ) -> ComposeDeploymentUpgradeProgressInfo {
        self.current_upgrade_domain_duration =
            Some(current_upgrade_domain_duration);
        self
    }

    pub fn current_upgrade_domain_duration(
        &self,
    ) -> Option<&::models::CurrentUpgradeDomainDuration> {
        self.current_upgrade_domain_duration.as_ref()
    }

    pub fn reset_current_upgrade_domain_duration(&mut self) {
        self.current_upgrade_domain_duration = None;
    }

    pub fn set_application_unhealthy_evaluations(
        &mut self,
        application_unhealthy_evaluations: ::models::ApplicationUnhealthyEvaluations,
    ) {
        self.application_unhealthy_evaluations =
            Some(application_unhealthy_evaluations);
    }

    pub fn with_application_unhealthy_evaluations(
        mut self,
        application_unhealthy_evaluations: ::models::ApplicationUnhealthyEvaluations,
    ) -> ComposeDeploymentUpgradeProgressInfo {
        self.application_unhealthy_evaluations =
            Some(application_unhealthy_evaluations);
        self
    }

    pub fn application_unhealthy_evaluations(
        &self,
    ) -> Option<&::models::ApplicationUnhealthyEvaluations> {
        self.application_unhealthy_evaluations.as_ref()
    }

    pub fn reset_application_unhealthy_evaluations(&mut self) {
        self.application_unhealthy_evaluations = None;
    }

    pub fn set_current_upgrade_domain_progress(
        &mut self,
        current_upgrade_domain_progress: ::models::CurrentUpgradeDomainProgressInfo,
    ) {
        self.current_upgrade_domain_progress =
            Some(current_upgrade_domain_progress);
    }

    pub fn with_current_upgrade_domain_progress(
        mut self,
        current_upgrade_domain_progress: ::models::CurrentUpgradeDomainProgressInfo,
    ) -> ComposeDeploymentUpgradeProgressInfo {
        self.current_upgrade_domain_progress =
            Some(current_upgrade_domain_progress);
        self
    }

    pub fn current_upgrade_domain_progress(
        &self,
    ) -> Option<&::models::CurrentUpgradeDomainProgressInfo> {
        self.current_upgrade_domain_progress.as_ref()
    }

    pub fn reset_current_upgrade_domain_progress(&mut self) {
        self.current_upgrade_domain_progress = None;
    }

    pub fn set_start_timestamp_utc(&mut self, start_timestamp_utc: String) {
        self.start_timestamp_utc = Some(start_timestamp_utc);
    }

    pub fn with_start_timestamp_utc(
        mut self,
        start_timestamp_utc: String,
    ) -> ComposeDeploymentUpgradeProgressInfo {
        self.start_timestamp_utc = Some(start_timestamp_utc);
        self
    }

    pub fn start_timestamp_utc(&self) -> Option<&String> {
        self.start_timestamp_utc.as_ref()
    }

    pub fn reset_start_timestamp_utc(&mut self) {
        self.start_timestamp_utc = None;
    }

    pub fn set_failure_timestamp_utc(&mut self, failure_timestamp_utc: String) {
        self.failure_timestamp_utc = Some(failure_timestamp_utc);
    }

    pub fn with_failure_timestamp_utc(
        mut self,
        failure_timestamp_utc: String,
    ) -> ComposeDeploymentUpgradeProgressInfo {
        self.failure_timestamp_utc = Some(failure_timestamp_utc);
        self
    }

    pub fn failure_timestamp_utc(&self) -> Option<&String> {
        self.failure_timestamp_utc.as_ref()
    }

    pub fn reset_failure_timestamp_utc(&mut self) {
        self.failure_timestamp_utc = None;
    }

    pub fn set_failure_reason(
        &mut self,
        failure_reason: ::models::FailureReason,
    ) {
        self.failure_reason = Some(failure_reason);
    }

    pub fn with_failure_reason(
        mut self,
        failure_reason: ::models::FailureReason,
    ) -> ComposeDeploymentUpgradeProgressInfo {
        self.failure_reason = Some(failure_reason);
        self
    }

    pub fn failure_reason(&self) -> Option<&::models::FailureReason> {
        self.failure_reason.as_ref()
    }

    pub fn reset_failure_reason(&mut self) {
        self.failure_reason = None;
    }

    pub fn set_upgrade_domain_progress_at_failure(
        &mut self,
        upgrade_domain_progress_at_failure: ::models::FailureUpgradeDomainProgressInfo,
    ) {
        self.upgrade_domain_progress_at_failure =
            Some(upgrade_domain_progress_at_failure);
    }

    pub fn with_upgrade_domain_progress_at_failure(
        mut self,
        upgrade_domain_progress_at_failure: ::models::FailureUpgradeDomainProgressInfo,
    ) -> ComposeDeploymentUpgradeProgressInfo {
        self.upgrade_domain_progress_at_failure =
            Some(upgrade_domain_progress_at_failure);
        self
    }

    pub fn upgrade_domain_progress_at_failure(
        &self,
    ) -> Option<&::models::FailureUpgradeDomainProgressInfo> {
        self.upgrade_domain_progress_at_failure.as_ref()
    }

    pub fn reset_upgrade_domain_progress_at_failure(&mut self) {
        self.upgrade_domain_progress_at_failure = None;
    }

    pub fn set_application_upgrade_status_details(
        &mut self,
        application_upgrade_status_details: String,
    ) {
        self.application_upgrade_status_details =
            Some(application_upgrade_status_details);
    }

    pub fn with_application_upgrade_status_details(
        mut self,
        application_upgrade_status_details: String,
    ) -> ComposeDeploymentUpgradeProgressInfo {
        self.application_upgrade_status_details =
            Some(application_upgrade_status_details);
        self
    }

    pub fn application_upgrade_status_details(&self) -> Option<&String> {
        self.application_upgrade_status_details.as_ref()
    }

    pub fn reset_application_upgrade_status_details(&mut self) {
        self.application_upgrade_status_details = None;
    }
}
