/*
 * Service Fabric Client APIs
 *
 * Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.
 *
 * OpenAPI spec version: 8.1
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// StatelessServicePartitionInfo : Information about a partition of a stateless Service Fabric service.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct StatelessServicePartitionInfo {
    /// The kind of service (Stateless or Stateful).
    #[serde(rename = "ServiceKind")]
    service_kind: ::models::ServiceKind,
    /// The health state of a Service Fabric entity such as Cluster, Node, Application, Service, Partition, Replica etc.
    #[serde(rename = "HealthState")]
    health_state: Option<::models::HealthState>,
    /// The status of the service fabric service partition.
    #[serde(rename = "PartitionStatus")]
    partition_status: Option<::models::ServicePartitionStatus>,
    /// Information about the partition identity, partitioning scheme and keys supported by it.
    #[serde(rename = "PartitionInformation")]
    partition_information: Option<::models::PartitionInformation>,
    /// Number of instances of this partition.
    #[serde(rename = "InstanceCount")]
    instance_count: Option<i64>,
    /// MinInstanceCount is the minimum number of instances that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
    #[serde(rename = "MinInstanceCount")]
    min_instance_count: Option<::models::MinInstanceCount>,
    /// MinInstancePercentage is the minimum percentage of InstanceCount that must be up to meet the EnsureAvailability safety check during operations like upgrade or deactivate node. The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 * InstanceCount) ). Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first converted into the number of nodes on which the instances are allowed to be placed according to the placement constraints on the service.
    #[serde(rename = "MinInstancePercentage")]
    min_instance_percentage: Option<::models::MinInstancePercentage>,
}

impl StatelessServicePartitionInfo {
    /// Information about a partition of a stateless Service Fabric service.
    pub fn new(
        service_kind: ::models::ServiceKind,
    ) -> StatelessServicePartitionInfo {
        StatelessServicePartitionInfo {
            service_kind,
            health_state: None,
            partition_status: None,
            partition_information: None,
            instance_count: None,
            min_instance_count: None,
            min_instance_percentage: None,
        }
    }

    pub fn set_service_kind(&mut self, service_kind: ::models::ServiceKind) {
        self.service_kind = service_kind;
    }

    pub fn with_service_kind(
        mut self,
        service_kind: ::models::ServiceKind,
    ) -> StatelessServicePartitionInfo {
        self.service_kind = service_kind;
        self
    }

    pub fn service_kind(&self) -> &::models::ServiceKind {
        &self.service_kind
    }

    pub fn set_health_state(&mut self, health_state: ::models::HealthState) {
        self.health_state = Some(health_state);
    }

    pub fn with_health_state(
        mut self,
        health_state: ::models::HealthState,
    ) -> StatelessServicePartitionInfo {
        self.health_state = Some(health_state);
        self
    }

    pub fn health_state(&self) -> Option<&::models::HealthState> {
        self.health_state.as_ref()
    }

    pub fn reset_health_state(&mut self) {
        self.health_state = None;
    }

    pub fn set_partition_status(
        &mut self,
        partition_status: ::models::ServicePartitionStatus,
    ) {
        self.partition_status = Some(partition_status);
    }

    pub fn with_partition_status(
        mut self,
        partition_status: ::models::ServicePartitionStatus,
    ) -> StatelessServicePartitionInfo {
        self.partition_status = Some(partition_status);
        self
    }

    pub fn partition_status(
        &self,
    ) -> Option<&::models::ServicePartitionStatus> {
        self.partition_status.as_ref()
    }

    pub fn reset_partition_status(&mut self) {
        self.partition_status = None;
    }

    pub fn set_partition_information(
        &mut self,
        partition_information: ::models::PartitionInformation,
    ) {
        self.partition_information = Some(partition_information);
    }

    pub fn with_partition_information(
        mut self,
        partition_information: ::models::PartitionInformation,
    ) -> StatelessServicePartitionInfo {
        self.partition_information = Some(partition_information);
        self
    }

    pub fn partition_information(
        &self,
    ) -> Option<&::models::PartitionInformation> {
        self.partition_information.as_ref()
    }

    pub fn reset_partition_information(&mut self) {
        self.partition_information = None;
    }

    pub fn set_instance_count(&mut self, instance_count: i64) {
        self.instance_count = Some(instance_count);
    }

    pub fn with_instance_count(
        mut self,
        instance_count: i64,
    ) -> StatelessServicePartitionInfo {
        self.instance_count = Some(instance_count);
        self
    }

    pub fn instance_count(&self) -> Option<&i64> {
        self.instance_count.as_ref()
    }

    pub fn reset_instance_count(&mut self) {
        self.instance_count = None;
    }

    pub fn set_min_instance_count(
        &mut self,
        min_instance_count: ::models::MinInstanceCount,
    ) {
        self.min_instance_count = Some(min_instance_count);
    }

    pub fn with_min_instance_count(
        mut self,
        min_instance_count: ::models::MinInstanceCount,
    ) -> StatelessServicePartitionInfo {
        self.min_instance_count = Some(min_instance_count);
        self
    }

    pub fn min_instance_count(&self) -> Option<&::models::MinInstanceCount> {
        self.min_instance_count.as_ref()
    }

    pub fn reset_min_instance_count(&mut self) {
        self.min_instance_count = None;
    }

    pub fn set_min_instance_percentage(
        &mut self,
        min_instance_percentage: ::models::MinInstancePercentage,
    ) {
        self.min_instance_percentage = Some(min_instance_percentage);
    }

    pub fn with_min_instance_percentage(
        mut self,
        min_instance_percentage: ::models::MinInstancePercentage,
    ) -> StatelessServicePartitionInfo {
        self.min_instance_percentage = Some(min_instance_percentage);
        self
    }

    pub fn min_instance_percentage(
        &self,
    ) -> Option<&::models::MinInstancePercentage> {
        self.min_instance_percentage.as_ref()
    }

    pub fn reset_min_instance_percentage(&mut self) {
        self.min_instance_percentage = None;
    }
}
