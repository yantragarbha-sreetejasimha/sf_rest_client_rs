/*
 * Service Fabric Client APIs
 *
 * Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.
 *
 * OpenAPI spec version: 7.1.0.45
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// Probe : Probes have a number of fields that you can use to control their behavior.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct Probe {
    /// The initial delay in seconds to start executing probe once codepackage has started.
    #[serde(rename = "initialDelaySeconds")]
    initial_delay_seconds: Option<i32>,
    /// Periodic seconds to execute probe.
    #[serde(rename = "periodSeconds")]
    period_seconds: Option<i32>,
    /// Period after which probe is considered as failed if it hasn't completed successfully.
    #[serde(rename = "timeoutSeconds")]
    timeout_seconds: Option<i32>,
    /// The count of successful probe executions after which probe is considered success.
    #[serde(rename = "successThreshold")]
    success_threshold: Option<i32>,
    /// The count of failures after which probe is considered failed.
    #[serde(rename = "failureThreshold")]
    failure_threshold: Option<i32>,
    /// Exec command to run inside the container.
    #[serde(rename = "exec")]
    exec: Option<::models::ProbeExec>,
    /// Http probe for the container.
    #[serde(rename = "httpGet")]
    http_get: Option<::models::ProbeHttpGet>,
    /// Tcp port to probe inside the container.
    #[serde(rename = "tcpSocket")]
    tcp_socket: Option<::models::ProbeTcpSocket>,
}

impl Default for Probe {
    fn default() -> Self {
        Self::new()
    }
}

impl Probe {
    /// Probes have a number of fields that you can use to control their behavior.
    pub fn new() -> Probe {
        Probe {
            initial_delay_seconds: None,
            period_seconds: None,
            timeout_seconds: None,
            success_threshold: None,
            failure_threshold: None,
            exec: None,
            http_get: None,
            tcp_socket: None,
        }
    }

    pub fn set_initial_delay_seconds(&mut self, initial_delay_seconds: i32) {
        self.initial_delay_seconds = Some(initial_delay_seconds);
    }

    pub fn with_initial_delay_seconds(
        mut self,
        initial_delay_seconds: i32,
    ) -> Probe {
        self.initial_delay_seconds = Some(initial_delay_seconds);
        self
    }

    pub fn initial_delay_seconds(&self) -> Option<&i32> {
        self.initial_delay_seconds.as_ref()
    }

    pub fn reset_initial_delay_seconds(&mut self) {
        self.initial_delay_seconds = None;
    }

    pub fn set_period_seconds(&mut self, period_seconds: i32) {
        self.period_seconds = Some(period_seconds);
    }

    pub fn with_period_seconds(mut self, period_seconds: i32) -> Probe {
        self.period_seconds = Some(period_seconds);
        self
    }

    pub fn period_seconds(&self) -> Option<&i32> {
        self.period_seconds.as_ref()
    }

    pub fn reset_period_seconds(&mut self) {
        self.period_seconds = None;
    }

    pub fn set_timeout_seconds(&mut self, timeout_seconds: i32) {
        self.timeout_seconds = Some(timeout_seconds);
    }

    pub fn with_timeout_seconds(mut self, timeout_seconds: i32) -> Probe {
        self.timeout_seconds = Some(timeout_seconds);
        self
    }

    pub fn timeout_seconds(&self) -> Option<&i32> {
        self.timeout_seconds.as_ref()
    }

    pub fn reset_timeout_seconds(&mut self) {
        self.timeout_seconds = None;
    }

    pub fn set_success_threshold(&mut self, success_threshold: i32) {
        self.success_threshold = Some(success_threshold);
    }

    pub fn with_success_threshold(mut self, success_threshold: i32) -> Probe {
        self.success_threshold = Some(success_threshold);
        self
    }

    pub fn success_threshold(&self) -> Option<&i32> {
        self.success_threshold.as_ref()
    }

    pub fn reset_success_threshold(&mut self) {
        self.success_threshold = None;
    }

    pub fn set_failure_threshold(&mut self, failure_threshold: i32) {
        self.failure_threshold = Some(failure_threshold);
    }

    pub fn with_failure_threshold(mut self, failure_threshold: i32) -> Probe {
        self.failure_threshold = Some(failure_threshold);
        self
    }

    pub fn failure_threshold(&self) -> Option<&i32> {
        self.failure_threshold.as_ref()
    }

    pub fn reset_failure_threshold(&mut self) {
        self.failure_threshold = None;
    }

    pub fn set_exec(&mut self, exec: ::models::ProbeExec) {
        self.exec = Some(exec);
    }

    pub fn with_exec(mut self, exec: ::models::ProbeExec) -> Probe {
        self.exec = Some(exec);
        self
    }

    pub fn exec(&self) -> Option<&::models::ProbeExec> {
        self.exec.as_ref()
    }

    pub fn reset_exec(&mut self) {
        self.exec = None;
    }

    pub fn set_http_get(&mut self, http_get: ::models::ProbeHttpGet) {
        self.http_get = Some(http_get);
    }

    pub fn with_http_get(mut self, http_get: ::models::ProbeHttpGet) -> Probe {
        self.http_get = Some(http_get);
        self
    }

    pub fn http_get(&self) -> Option<&::models::ProbeHttpGet> {
        self.http_get.as_ref()
    }

    pub fn reset_http_get(&mut self) {
        self.http_get = None;
    }

    pub fn set_tcp_socket(&mut self, tcp_socket: ::models::ProbeTcpSocket) {
        self.tcp_socket = Some(tcp_socket);
    }

    pub fn with_tcp_socket(
        mut self,
        tcp_socket: ::models::ProbeTcpSocket,
    ) -> Probe {
        self.tcp_socket = Some(tcp_socket);
        self
    }

    pub fn tcp_socket(&self) -> Option<&::models::ProbeTcpSocket> {
        self.tcp_socket.as_ref()
    }

    pub fn reset_tcp_socket(&mut self) {
        self.tcp_socket = None;
    }
}
