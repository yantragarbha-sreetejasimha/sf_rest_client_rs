/*
 * Service Fabric Client APIs
 *
 * Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.
 *
 * OpenAPI spec version: 6.4.0.36
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// ImageStoreCopyDescription : Information about how to copy image store content from one image store relative path to another image store relative path.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct ImageStoreCopyDescription {
    /// The relative path of source image store content to be copied from.
    #[serde(rename = "RemoteSource")]
    remote_source: String,
    /// The relative path of destination image store content to be copied to.
    #[serde(rename = "RemoteDestination")]
    remote_destination: String,
    /// The list of the file names to be skipped for copying.
    #[serde(rename = "SkipFiles")]
    skip_files: Option<Vec<String>>,
    /// Indicates whether to check mark file during copying. The property is true if checking mark file is required, false otherwise. The mark file is used to check whether the folder is well constructed. If the property is true and mark file does not exist, the copy is skipped.
    #[serde(rename = "CheckMarkFile")]
    check_mark_file: Option<bool>,
}

impl ImageStoreCopyDescription {
    /// Information about how to copy image store content from one image store relative path to another image store relative path.
    pub fn new(
        remote_source: String,
        remote_destination: String,
    ) -> ImageStoreCopyDescription {
        ImageStoreCopyDescription {
            remote_source,
            remote_destination,
            skip_files: None,
            check_mark_file: None,
        }
    }

    pub fn set_remote_source(&mut self, remote_source: String) {
        self.remote_source = remote_source;
    }

    pub fn with_remote_source(
        mut self,
        remote_source: String,
    ) -> ImageStoreCopyDescription {
        self.remote_source = remote_source;
        self
    }

    pub fn remote_source(&self) -> &String {
        &self.remote_source
    }

    pub fn set_remote_destination(&mut self, remote_destination: String) {
        self.remote_destination = remote_destination;
    }

    pub fn with_remote_destination(
        mut self,
        remote_destination: String,
    ) -> ImageStoreCopyDescription {
        self.remote_destination = remote_destination;
        self
    }

    pub fn remote_destination(&self) -> &String {
        &self.remote_destination
    }

    pub fn set_skip_files(&mut self, skip_files: Vec<String>) {
        self.skip_files = Some(skip_files);
    }

    pub fn with_skip_files(
        mut self,
        skip_files: Vec<String>,
    ) -> ImageStoreCopyDescription {
        self.skip_files = Some(skip_files);
        self
    }

    pub fn skip_files(&self) -> Option<&Vec<String>> {
        self.skip_files.as_ref()
    }

    pub fn reset_skip_files(&mut self) {
        self.skip_files = None;
    }

    pub fn set_check_mark_file(&mut self, check_mark_file: bool) {
        self.check_mark_file = Some(check_mark_file);
    }

    pub fn with_check_mark_file(
        mut self,
        check_mark_file: bool,
    ) -> ImageStoreCopyDescription {
        self.check_mark_file = Some(check_mark_file);
        self
    }

    pub fn check_mark_file(&self) -> Option<&bool> {
        self.check_mark_file.as_ref()
    }

    pub fn reset_check_mark_file(&mut self) {
        self.check_mark_file = None;
    }
}
