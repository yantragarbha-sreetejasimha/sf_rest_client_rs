/*
 * Service Fabric Client APIs
 *
 * Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.
 *
 * OpenAPI spec version: 6.4.0.36
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// ContainerInstanceView : Runtime information of a container instance.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct ContainerInstanceView {
    /// The number of times the container has been restarted.
    #[serde(rename = "restartCount")]
    restart_count: Option<i32>,
    /// Current container instance state.
    #[serde(rename = "currentState")]
    current_state: Option<::models::ContainerState>,
    /// Previous container instance state.
    #[serde(rename = "previousState")]
    previous_state: Option<::models::ContainerState>,
    /// The events of this container instance.
    #[serde(rename = "events")]
    events: Option<Vec<::models::ContainerEvent>>,
}

impl Default for ContainerInstanceView {
    fn default() -> Self {
        Self::new()
    }
}

impl ContainerInstanceView {
    /// Runtime information of a container instance.
    pub fn new() -> ContainerInstanceView {
        ContainerInstanceView {
            restart_count: None,
            current_state: None,
            previous_state: None,
            events: None,
        }
    }

    pub fn set_restart_count(&mut self, restart_count: i32) {
        self.restart_count = Some(restart_count);
    }

    pub fn with_restart_count(
        mut self,
        restart_count: i32,
    ) -> ContainerInstanceView {
        self.restart_count = Some(restart_count);
        self
    }

    pub fn restart_count(&self) -> Option<&i32> {
        self.restart_count.as_ref()
    }

    pub fn reset_restart_count(&mut self) {
        self.restart_count = None;
    }

    pub fn set_current_state(
        &mut self,
        current_state: ::models::ContainerState,
    ) {
        self.current_state = Some(current_state);
    }

    pub fn with_current_state(
        mut self,
        current_state: ::models::ContainerState,
    ) -> ContainerInstanceView {
        self.current_state = Some(current_state);
        self
    }

    pub fn current_state(&self) -> Option<&::models::ContainerState> {
        self.current_state.as_ref()
    }

    pub fn reset_current_state(&mut self) {
        self.current_state = None;
    }

    pub fn set_previous_state(
        &mut self,
        previous_state: ::models::ContainerState,
    ) {
        self.previous_state = Some(previous_state);
    }

    pub fn with_previous_state(
        mut self,
        previous_state: ::models::ContainerState,
    ) -> ContainerInstanceView {
        self.previous_state = Some(previous_state);
        self
    }

    pub fn previous_state(&self) -> Option<&::models::ContainerState> {
        self.previous_state.as_ref()
    }

    pub fn reset_previous_state(&mut self) {
        self.previous_state = None;
    }

    pub fn set_events(&mut self, events: Vec<::models::ContainerEvent>) {
        self.events = Some(events);
    }

    pub fn with_events(
        mut self,
        events: Vec<::models::ContainerEvent>,
    ) -> ContainerInstanceView {
        self.events = Some(events);
        self
    }

    pub fn events(&self) -> Option<&Vec<::models::ContainerEvent>> {
        self.events.as_ref()
    }

    pub fn reset_events(&mut self) {
        self.events = None;
    }
}
