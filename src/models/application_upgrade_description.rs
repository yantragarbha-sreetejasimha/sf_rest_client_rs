/*
 * Service Fabric Client APIs
 *
 * Service Fabric REST Client APIs allows management of Service Fabric clusters, applications and services.
 *
 * OpenAPI spec version: 7.2.0.46
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// ApplicationUpgradeDescription : Describes the parameters for an application upgrade. Note that upgrade description replaces the existing application description. This means that if the parameters are not specified, the existing parameters on the applications will be overwritten with the empty parameters list. This would result in the application using the default value of the parameters from the application manifest. If you do not want to change any existing parameter values, please get the application parameters first using the GetApplicationInfo query and then supply those values as Parameters in this ApplicationUpgradeDescription.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct ApplicationUpgradeDescription {
    /// The name of the target application, including the 'fabric:' URI scheme.
    #[serde(rename = "Name")]
    name: ::models::TargetApplicationName,
    /// The target application type version (found in the application manifest) for the application upgrade.
    #[serde(rename = "TargetApplicationTypeVersion")]
    target_application_type_version: ::models::TargetApplicationTypeVersion,
    /// List of application parameters with overridden values from their default values specified in the application manifest.
    #[serde(rename = "Parameters")]
    parameters: Option<::models::ApplicationParameterList>,
    /// The kind of upgrade out of the following possible values.
    #[serde(rename = "UpgradeKind")]
    upgrade_kind: ::models::UpgradeKind,
    /// The mode used to monitor health during a rolling upgrade. The values are UnmonitoredAuto, UnmonitoredManual, and Monitored.
    #[serde(rename = "RollingUpgradeMode")]
    rolling_upgrade_mode: Option<::models::UpgradeMode>,
    /// The maximum amount of time to block processing of an upgrade domain and prevent loss of availability when there are unexpected issues. When this timeout expires, processing of the upgrade domain will proceed regardless of availability loss issues. The timeout is reset at the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
    #[serde(rename = "UpgradeReplicaSetCheckTimeoutInSeconds")]
    upgrade_replica_set_check_timeout_in_seconds:
        Option<::models::UpgradeReplicaSetCheckTimeout>,
    /// If true, then processes are forcefully restarted during upgrade even when the code version has not changed (the upgrade only changes configuration or data).
    #[serde(rename = "ForceRestart")]
    force_restart: Option<::models::ForceRestart>,
    /// Defines the order in which an upgrade proceeds through the cluster.
    #[serde(rename = "SortOrder")]
    sort_order: Option<::models::UpgradeSortOrder>,
    /// Describes the parameters for monitoring an upgrade in Monitored mode.
    #[serde(rename = "MonitoringPolicy")]
    monitoring_policy: Option<::models::MonitoringPolicyDescription>,
    /// Defines a health policy used to evaluate the health of an application or one of its children entities.
    #[serde(rename = "ApplicationHealthPolicy")]
    application_health_policy: Option<::models::ApplicationHealthPolicy>,
    /// Duration in seconds, to wait before a stateless instance is closed, to allow the active requests to drain gracefully. This would be effective when the instance is closing during the application/cluster upgrade, only for those instances which have a non-zero delay duration configured in the service description. See InstanceCloseDelayDurationSeconds property in $ref: \"#/definitions/StatelessServiceDescription.yaml\" for details. Note, the default value of InstanceCloseDelayDurationInSeconds is 4294967295, which indicates that the behavior will entirely depend on the delay configured in the stateless service description.
    #[serde(rename = "InstanceCloseDelayDurationInSeconds")]
    instance_close_delay_duration_in_seconds:
        Option<::models::InstanceCloseDelayDurationInSeconds>,
}

impl ApplicationUpgradeDescription {
    /// Describes the parameters for an application upgrade. Note that upgrade description replaces the existing application description. This means that if the parameters are not specified, the existing parameters on the applications will be overwritten with the empty parameters list. This would result in the application using the default value of the parameters from the application manifest. If you do not want to change any existing parameter values, please get the application parameters first using the GetApplicationInfo query and then supply those values as Parameters in this ApplicationUpgradeDescription.
    pub fn new(
        name: ::models::TargetApplicationName,
        target_application_type_version: ::models::TargetApplicationTypeVersion,
        upgrade_kind: ::models::UpgradeKind,
    ) -> ApplicationUpgradeDescription {
        ApplicationUpgradeDescription {
            name,
            target_application_type_version,
            parameters: None,
            upgrade_kind,
            rolling_upgrade_mode: None,
            upgrade_replica_set_check_timeout_in_seconds: None,
            force_restart: None,
            sort_order: None,
            monitoring_policy: None,
            application_health_policy: None,
            instance_close_delay_duration_in_seconds: None,
        }
    }

    pub fn set_name(&mut self, name: ::models::TargetApplicationName) {
        self.name = name;
    }

    pub fn with_name(
        mut self,
        name: ::models::TargetApplicationName,
    ) -> ApplicationUpgradeDescription {
        self.name = name;
        self
    }

    pub fn name(&self) -> &::models::TargetApplicationName {
        &self.name
    }

    pub fn set_target_application_type_version(
        &mut self,
        target_application_type_version: ::models::TargetApplicationTypeVersion,
    ) {
        self.target_application_type_version = target_application_type_version;
    }

    pub fn with_target_application_type_version(
        mut self,
        target_application_type_version: ::models::TargetApplicationTypeVersion,
    ) -> ApplicationUpgradeDescription {
        self.target_application_type_version = target_application_type_version;
        self
    }

    pub fn target_application_type_version(
        &self,
    ) -> &::models::TargetApplicationTypeVersion {
        &self.target_application_type_version
    }

    pub fn set_parameters(
        &mut self,
        parameters: ::models::ApplicationParameterList,
    ) {
        self.parameters = Some(parameters);
    }

    pub fn with_parameters(
        mut self,
        parameters: ::models::ApplicationParameterList,
    ) -> ApplicationUpgradeDescription {
        self.parameters = Some(parameters);
        self
    }

    pub fn parameters(&self) -> Option<&::models::ApplicationParameterList> {
        self.parameters.as_ref()
    }

    pub fn reset_parameters(&mut self) {
        self.parameters = None;
    }

    pub fn set_upgrade_kind(&mut self, upgrade_kind: ::models::UpgradeKind) {
        self.upgrade_kind = upgrade_kind;
    }

    pub fn with_upgrade_kind(
        mut self,
        upgrade_kind: ::models::UpgradeKind,
    ) -> ApplicationUpgradeDescription {
        self.upgrade_kind = upgrade_kind;
        self
    }

    pub fn upgrade_kind(&self) -> &::models::UpgradeKind {
        &self.upgrade_kind
    }

    pub fn set_rolling_upgrade_mode(
        &mut self,
        rolling_upgrade_mode: ::models::UpgradeMode,
    ) {
        self.rolling_upgrade_mode = Some(rolling_upgrade_mode);
    }

    pub fn with_rolling_upgrade_mode(
        mut self,
        rolling_upgrade_mode: ::models::UpgradeMode,
    ) -> ApplicationUpgradeDescription {
        self.rolling_upgrade_mode = Some(rolling_upgrade_mode);
        self
    }

    pub fn rolling_upgrade_mode(&self) -> Option<&::models::UpgradeMode> {
        self.rolling_upgrade_mode.as_ref()
    }

    pub fn reset_rolling_upgrade_mode(&mut self) {
        self.rolling_upgrade_mode = None;
    }

    pub fn set_upgrade_replica_set_check_timeout_in_seconds(
        &mut self,
        upgrade_replica_set_check_timeout_in_seconds: ::models::UpgradeReplicaSetCheckTimeout,
    ) {
        self.upgrade_replica_set_check_timeout_in_seconds =
            Some(upgrade_replica_set_check_timeout_in_seconds);
    }

    pub fn with_upgrade_replica_set_check_timeout_in_seconds(
        mut self,
        upgrade_replica_set_check_timeout_in_seconds: ::models::UpgradeReplicaSetCheckTimeout,
    ) -> ApplicationUpgradeDescription {
        self.upgrade_replica_set_check_timeout_in_seconds =
            Some(upgrade_replica_set_check_timeout_in_seconds);
        self
    }

    pub fn upgrade_replica_set_check_timeout_in_seconds(
        &self,
    ) -> Option<&::models::UpgradeReplicaSetCheckTimeout> {
        self.upgrade_replica_set_check_timeout_in_seconds.as_ref()
    }

    pub fn reset_upgrade_replica_set_check_timeout_in_seconds(&mut self) {
        self.upgrade_replica_set_check_timeout_in_seconds = None;
    }

    pub fn set_force_restart(&mut self, force_restart: ::models::ForceRestart) {
        self.force_restart = Some(force_restart);
    }

    pub fn with_force_restart(
        mut self,
        force_restart: ::models::ForceRestart,
    ) -> ApplicationUpgradeDescription {
        self.force_restart = Some(force_restart);
        self
    }

    pub fn force_restart(&self) -> Option<&::models::ForceRestart> {
        self.force_restart.as_ref()
    }

    pub fn reset_force_restart(&mut self) {
        self.force_restart = None;
    }

    pub fn set_sort_order(&mut self, sort_order: ::models::UpgradeSortOrder) {
        self.sort_order = Some(sort_order);
    }

    pub fn with_sort_order(
        mut self,
        sort_order: ::models::UpgradeSortOrder,
    ) -> ApplicationUpgradeDescription {
        self.sort_order = Some(sort_order);
        self
    }

    pub fn sort_order(&self) -> Option<&::models::UpgradeSortOrder> {
        self.sort_order.as_ref()
    }

    pub fn reset_sort_order(&mut self) {
        self.sort_order = None;
    }

    pub fn set_monitoring_policy(
        &mut self,
        monitoring_policy: ::models::MonitoringPolicyDescription,
    ) {
        self.monitoring_policy = Some(monitoring_policy);
    }

    pub fn with_monitoring_policy(
        mut self,
        monitoring_policy: ::models::MonitoringPolicyDescription,
    ) -> ApplicationUpgradeDescription {
        self.monitoring_policy = Some(monitoring_policy);
        self
    }

    pub fn monitoring_policy(
        &self,
    ) -> Option<&::models::MonitoringPolicyDescription> {
        self.monitoring_policy.as_ref()
    }

    pub fn reset_monitoring_policy(&mut self) {
        self.monitoring_policy = None;
    }

    pub fn set_application_health_policy(
        &mut self,
        application_health_policy: ::models::ApplicationHealthPolicy,
    ) {
        self.application_health_policy = Some(application_health_policy);
    }

    pub fn with_application_health_policy(
        mut self,
        application_health_policy: ::models::ApplicationHealthPolicy,
    ) -> ApplicationUpgradeDescription {
        self.application_health_policy = Some(application_health_policy);
        self
    }

    pub fn application_health_policy(
        &self,
    ) -> Option<&::models::ApplicationHealthPolicy> {
        self.application_health_policy.as_ref()
    }

    pub fn reset_application_health_policy(&mut self) {
        self.application_health_policy = None;
    }

    pub fn set_instance_close_delay_duration_in_seconds(
        &mut self,
        instance_close_delay_duration_in_seconds: ::models::InstanceCloseDelayDurationInSeconds,
    ) {
        self.instance_close_delay_duration_in_seconds =
            Some(instance_close_delay_duration_in_seconds);
    }

    pub fn with_instance_close_delay_duration_in_seconds(
        mut self,
        instance_close_delay_duration_in_seconds: ::models::InstanceCloseDelayDurationInSeconds,
    ) -> ApplicationUpgradeDescription {
        self.instance_close_delay_duration_in_seconds =
            Some(instance_close_delay_duration_in_seconds);
        self
    }

    pub fn instance_close_delay_duration_in_seconds(
        &self,
    ) -> Option<&::models::InstanceCloseDelayDurationInSeconds> {
        self.instance_close_delay_duration_in_seconds.as_ref()
    }

    pub fn reset_instance_close_delay_duration_in_seconds(&mut self) {
        self.instance_close_delay_duration_in_seconds = None;
    }
}
